<!DOCTYPE html>
<html>
<head>
    <title>Logging Performance Test - Smart Resolution Calculator</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 1200px;
            margin: 40px auto;
            padding: 20px;
            background: #f5f5f5;
        }
        h1 {
            color: #333;
            border-bottom: 3px solid #4CAF50;
            padding-bottom: 10px;
        }
        .test-section {
            background: white;
            padding: 20px;
            margin: 20px 0;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .controls {
            margin: 20px 0;
        }
        button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 12px 24px;
            font-size: 16px;
            border-radius: 4px;
            cursor: pointer;
            margin-right: 10px;
        }
        button:hover {
            background: #45a049;
        }
        button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }
        .results {
            margin-top: 20px;
            font-family: 'Courier New', monospace;
            background: #f9f9f9;
            padding: 15px;
            border-radius: 4px;
            border-left: 4px solid #4CAF50;
        }
        .metric {
            margin: 10px 0;
            padding: 8px;
            background: white;
            border-radius: 4px;
        }
        .metric-label {
            font-weight: bold;
            color: #555;
        }
        .metric-value {
            color: #2196F3;
            font-size: 18px;
        }
        .warning {
            background: #fff3cd;
            border-left: 4px solid #ffc107;
            padding: 15px;
            margin: 20px 0;
            border-radius: 4px;
        }
        .success {
            background: #d4edda;
            border-left: 4px solid #28a745;
            padding: 15px;
            margin: 20px 0;
            border-radius: 4px;
        }
        .status {
            padding: 10px;
            margin: 10px 0;
            border-radius: 4px;
        }
        .status.running {
            background: #e3f2fd;
            color: #1976d2;
        }
        .status.complete {
            background: #e8f5e9;
            color: #388e3c;
        }
        pre {
            background: #f5f5f5;
            padding: 10px;
            border-radius: 4px;
            overflow-x: auto;
        }
    </style>
</head>
<body>
    <h1>üî¨ Logging Performance Test - Smart Resolution Calculator</h1>

    <div class="test-section">
        <h2>Test Configuration</h2>
        <div class="controls">
            <label>
                Iterations per test:
                <input type="number" id="iterations" value="10000" min="100" max="100000" step="1000" style="width: 100px; padding: 5px;">
            </label>
            <br><br>
            <label>
                Widget count:
                <input type="number" id="widgetCount" value="20" min="5" max="50" step="5" style="width: 100px; padding: 5px;">
            </label>
        </div>
        <p><strong>Current debug state:</strong> <span id="debugState"></span></p>
        <p style="font-size: 14px; color: #666;">
            This test measures the overhead of logging calls in serialization/deserialization operations
            by comparing performance with debug enabled vs disabled.
        </p>
    </div>

    <div class="test-section">
        <h2>Performance Tests</h2>
        <div class="controls">
            <button id="runTestBtn" onclick="runAllTests()">Run All Tests</button>
            <button onclick="clearResults()">Clear Results</button>
            <button onclick="location.reload()">Reset Page</button>
        </div>
        <div id="status"></div>
        <div id="results"></div>
    </div>

    <div class="test-section">
        <h2>Test Scenarios</h2>
        <ol>
            <li><strong>Baseline (No Logging)</strong> - Pure serialization without any logging code</li>
            <li><strong>With Logging (Debug OFF)</strong> - Logging code present but debug disabled (normal user)</li>
            <li><strong>With Logging (Debug ON)</strong> - Logging code present and debug enabled (developer)</li>
            <li><strong>Argument Evaluation Cost</strong> - Measures cost of JSON.stringify and template literals</li>
        </ol>
    </div>

    <script type="module">
        import { DebugLogger } from '../../web/utils/debug_logger.js';

        // Display current debug state
        const debugState = localStorage.getItem('DEBUG_SMART_RES_CALC') === 'true';
        document.getElementById('debugState').textContent = debugState ?
            '‚úÖ ENABLED (localStorage.getItem("DEBUG_SMART_RES_CALC") === "true")' :
            '‚ùå DISABLED';

        // Create test logger
        const testLogger = new DebugLogger('PerformanceTest');

        // Generate mock widget data
        function generateMockWidgets(count) {
            const widgets = [];
            for (let i = 0; i < count; i++) {
                widgets.push({
                    name: `widget_${i}`,
                    type: i % 3 === 0 ? 'combo' : (i % 3 === 1 ? 'number' : 'toggle'),
                    value: i % 2 === 0 ? `value_${i}` : i * 1.5,
                    options: { values: ['option1', 'option2', 'option3'] }
                });
            }
            return widgets;
        }

        // Test 1: Baseline - No logging
        function testBaseline(widgets, iterations) {
            const start = performance.now();

            for (let i = 0; i < iterations; i++) {
                // Simulate serialization without logging
                const widgetsByName = {};
                widgets.forEach(widget => {
                    widgetsByName[widget.name] = widget.value;
                });
            }

            const end = performance.now();
            return end - start;
        }

        // Test 2: With logging (current implementation)
        function testWithLogging(widgets, iterations, logger) {
            const start = performance.now();

            for (let i = 0; i < iterations; i++) {
                // Simulate serialization WITH logging
                const widgetsByName = {};
                widgets.forEach(widget => {
                    widgetsByName[widget.name] = widget.value;
                });

                // This is what we do in our actual code
                logger.debug('[SERIALIZE] Saved widgets by name:', widgetsByName);

                // Simulate restore logging
                widgets.forEach(widget => {
                    logger.debug(`[NAME-BASED-RESTORE] Restored ${widget.name} = ${JSON.stringify(widget.value)}`);
                });
            }

            const end = performance.now();
            return end - start;
        }

        // Test 3: Argument evaluation cost only
        function testArgumentEvaluation(widgets, iterations) {
            const start = performance.now();

            for (let i = 0; i < iterations; i++) {
                const widgetsByName = {};
                widgets.forEach(widget => {
                    widgetsByName[widget.name] = widget.value;
                });

                // Evaluate arguments but don't call logger (simulates dead code branch)
                // This measures ONLY the argument preparation cost
                widgets.forEach(widget => {
                    const msg = `[NAME-BASED-RESTORE] Restored ${widget.name} = ${JSON.stringify(widget.value)}`;
                    // Don't do anything with msg - just measure the cost of creating it
                });
            }

            const end = performance.now();
            return end - start;
        }

        // Test 4: Zero-cost logging pattern (guarded)
        function testGuardedLogging(widgets, iterations, logger) {
            const start = performance.now();

            for (let i = 0; i < iterations; i++) {
                const widgetsByName = {};
                widgets.forEach(widget => {
                    widgetsByName[widget.name] = widget.value;
                });

                // Guard expensive operations
                if (logger.debugEnabled) {
                    logger.debug('[SERIALIZE] Saved widgets by name:', widgetsByName);
                }

                widgets.forEach(widget => {
                    if (logger.debugEnabled) {
                        logger.debug(`[NAME-BASED-RESTORE] Restored ${widget.name} = ${JSON.stringify(widget.value)}`);
                    }
                });
            }

            const end = performance.now();
            return end - start;
        }

        // Run all tests
        window.runAllTests = async function() {
            const iterations = parseInt(document.getElementById('iterations').value);
            const widgetCount = parseInt(document.getElementById('widgetCount').value);
            const btn = document.getElementById('runTestBtn');
            const statusDiv = document.getElementById('status');
            const resultsDiv = document.getElementById('results');

            btn.disabled = true;
            statusDiv.innerHTML = '<div class="status running">üîÑ Running tests...</div>';
            resultsDiv.innerHTML = '';

            // Generate test data
            const widgets = generateMockWidgets(widgetCount);

            // Run tests with small delays to allow UI updates
            await new Promise(resolve => setTimeout(resolve, 100));

            const baselineTime = testBaseline(widgets, iterations);
            statusDiv.innerHTML += '<div class="status running">‚úì Baseline test complete</div>';
            await new Promise(resolve => setTimeout(resolve, 100));

            const withLoggingTime = testWithLogging(widgets, iterations, testLogger);
            statusDiv.innerHTML += '<div class="status running">‚úì With logging test complete</div>';
            await new Promise(resolve => setTimeout(resolve, 100));

            const argEvalTime = testArgumentEvaluation(widgets, iterations);
            statusDiv.innerHTML += '<div class="status running">‚úì Argument evaluation test complete</div>';
            await new Promise(resolve => setTimeout(resolve, 100));

            const guardedTime = testGuardedLogging(widgets, iterations, testLogger);
            statusDiv.innerHTML += '<div class="status complete">‚úì All tests complete</div>';

            // Calculate metrics
            const overhead = withLoggingTime - baselineTime;
            const overheadPercent = ((overhead / baselineTime) * 100).toFixed(2);
            const perOperation = (overhead / iterations).toFixed(4);
            const argOverhead = argEvalTime - baselineTime;
            const argOverheadPercent = ((argOverhead / baselineTime) * 100).toFixed(2);
            const guardedOverhead = guardedTime - baselineTime;
            const guardedOverheadPercent = ((guardedOverhead / baselineTime) * 100).toFixed(2);

            // Display results
            let html = `
                <h3>Test Results</h3>
                <div class="metric">
                    <span class="metric-label">Iterations:</span>
                    <span class="metric-value">${iterations.toLocaleString()}</span>
                </div>
                <div class="metric">
                    <span class="metric-label">Widgets per iteration:</span>
                    <span class="metric-value">${widgetCount}</span>
                </div>
                <div class="metric">
                    <span class="metric-label">Total operations:</span>
                    <span class="metric-value">${(iterations * widgetCount).toLocaleString()}</span>
                </div>

                <h4>Timing Results</h4>
                <div class="metric">
                    <span class="metric-label">Baseline (no logging):</span>
                    <span class="metric-value">${baselineTime.toFixed(2)} ms</span>
                </div>
                <div class="metric">
                    <span class="metric-label">With logging (current):</span>
                    <span class="metric-value">${withLoggingTime.toFixed(2)} ms</span>
                </div>
                <div class="metric">
                    <span class="metric-label">Argument evaluation only:</span>
                    <span class="metric-value">${argEvalTime.toFixed(2)} ms</span>
                </div>
                <div class="metric">
                    <span class="metric-label">Guarded logging (optimized):</span>
                    <span class="metric-value">${guardedTime.toFixed(2)} ms</span>
                </div>

                <h4>Performance Impact</h4>
                <div class="metric">
                    <span class="metric-label">Current overhead:</span>
                    <span class="metric-value">${overhead.toFixed(2)} ms (+${overheadPercent}%)</span>
                </div>
                <div class="metric">
                    <span class="metric-label">Argument evaluation cost:</span>
                    <span class="metric-value">${argOverhead.toFixed(2)} ms (+${argOverheadPercent}%)</span>
                </div>
                <div class="metric">
                    <span class="metric-label">Guarded overhead:</span>
                    <span class="metric-value">${guardedOverhead.toFixed(2)} ms (+${guardedOverheadPercent}%)</span>
                </div>
                <div class="metric">
                    <span class="metric-label">Per-operation cost:</span>
                    <span class="metric-value">${perOperation} ms</span>
                </div>
            `;

            // Add interpretation
            if (overheadPercent < 1) {
                html += '<div class="success">‚úÖ <strong>Negligible impact:</strong> Less than 1% overhead. No optimization needed.</div>';
            } else if (overheadPercent < 5) {
                html += '<div class="warning">‚ö†Ô∏è <strong>Minor impact:</strong> ' + overheadPercent + '% overhead. Consider optimizing if this is a hot path.</div>';
            } else {
                html += '<div class="warning">‚ùå <strong>Significant impact:</strong> ' + overheadPercent + '% overhead. Optimization recommended!</div>';
            }

            if (argOverheadPercent > 2) {
                html += '<div class="warning">‚ö†Ô∏è <strong>Argument evaluation is expensive:</strong> ' + argOverheadPercent + '% overhead from JSON.stringify and template literals. Use guarded pattern.</div>';
            }

            // Show improvement from guarded pattern
            const improvement = ((overhead - guardedOverhead) / overhead * 100).toFixed(1);
            if (improvement > 10) {
                html += '<div class="success">üí° <strong>Guarded pattern improvement:</strong> ' + improvement + '% faster than current implementation.</div>';
            }

            resultsDiv.innerHTML = html;
            btn.disabled = false;
        };

        window.clearResults = function() {
            document.getElementById('results').innerHTML = '';
            document.getElementById('status').innerHTML = '';
        };
    </script>
</body>
</html>
